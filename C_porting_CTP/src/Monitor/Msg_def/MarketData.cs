// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static partial class MarketData {

  #region Extension registration
  public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
  }
  #endregion
  #region Static variables
  internal static pbd::MessageDescriptor internal__static_MarketDataMsg__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::MarketDataMsg, global::MarketDataMsg.Builder> internal__static_MarketDataMsg__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_InstrumentInfo__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::InstrumentInfo, global::InstrumentInfo.Builder> internal__static_InstrumentInfo__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_InstrumentList__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::InstrumentList, global::InstrumentList.Builder> internal__static_InstrumentList__FieldAccessorTable;
  #endregion
  #region Descriptor
  public static pbd::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbd::FileDescriptor descriptor;
  
  static MarketData() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        string.Concat(
          "ChZsY3RzL21hcmtldF9kYXRhLnByb3RvIqMECg1NYXJrZXREYXRhTXNnEhAK", 
          "BnN5bWJvbBgBIAIoCToAEhQKClRyYWRpbmdEYXkYAiACKAk6ABIUCgpVcGRh", 
          "dGVUaW1lGAMgAigJOgASGQoOVXBkYXRlTWlsbGlzZWMYBCACKAU6ATASFAoJ", 
          "TGFzdFByaWNlGAUgAigBOgEwEhcKDE9wZW5JbnRlcmVzdBgGIAIoAToBMBId", 
          "ChJkZWx0YU9wZW5JbnN0ZXJlc3QYByACKAU6ATASGgoPVXBwZXJMaW1pdFBy", 
          "aWNlGAggAigBOgEwEhoKD0xvd2VyTGltaXRQcmljZRgJIAIoAToBMBIRCgZW", 
          "b2x1bWUYCiACKAU6ATASFAoJYWNjVm9sdW1lGAsgAigFOgEwEhMKCFR1cm5v", 
          "dmVyGAwgAigBOgEwEhYKC2FjY1R1cm5vdmVyGA0gAigBOgEwEhMKCEFza1By", 
          "aWNlGA4gAigBOgEwEhQKCUFza1ZvbHVtZRgPIAIoBToBMBITCghCaWRQcmlj", 
          "ZRgQIAIoAToBMBIUCglCaWRWb2x1bWUYESACKAU6ATASGQoOQXZnUHJpY2VJ", 
          "blRpY2sYEiACKAE6ATASGAoNUHJlQ2xvc2VQcmljZRgTIAIoAToBMBIdChJQ", 
          "cmVTZXR0bGVtZW50UHJpY2UYFCACKAE6ATASGgoPUHJlT3BlbkludGVyZXN0", 
          "GBUgAigBOgEwEhcKDEF2ZXJhZ2VQcmljZRgWIAIoAToBMCI4Cg5JbnN0cnVt", 
          "ZW50SW5mbxIQCgZTeW1ib2wYASACKAk6ABIUCglQcmljZVRpY2sYAiACKAE6", 
          "ATEiLgoOSW5zdHJ1bWVudExpc3QSHAoDbHN0GAEgAygLMg8uSW5zdHJ1bWVu", 
        "dEluZm9CAkgB"));
    pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
      descriptor = root;
      internal__static_MarketDataMsg__Descriptor = Descriptor.MessageTypes[0];
      internal__static_MarketDataMsg__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::MarketDataMsg, global::MarketDataMsg.Builder>(internal__static_MarketDataMsg__Descriptor,
              new string[] { "Symbol", "TradingDay", "UpdateTime", "UpdateMillisec", "LastPrice", "OpenInterest", "DeltaOpenInsterest", "UpperLimitPrice", "LowerLimitPrice", "Volume", "AccVolume", "Turnover", "AccTurnover", "AskPrice", "AskVolume", "BidPrice", "BidVolume", "AvgPriceInTick", "PreClosePrice", "PreSettlementPrice", "PreOpenInterest", "AveragePrice", });
      internal__static_InstrumentInfo__Descriptor = Descriptor.MessageTypes[1];
      internal__static_InstrumentInfo__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::InstrumentInfo, global::InstrumentInfo.Builder>(internal__static_InstrumentInfo__Descriptor,
              new string[] { "Symbol", "PriceTick", });
      internal__static_InstrumentList__Descriptor = Descriptor.MessageTypes[2];
      internal__static_InstrumentList__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::InstrumentList, global::InstrumentList.Builder>(internal__static_InstrumentList__Descriptor,
              new string[] { "Lst", });
      return null;
    };
    pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
        new pbd::FileDescriptor[] {
        }, assigner);
  }
  #endregion
  
}
#region Messages
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class MarketDataMsg : pb::GeneratedMessage<MarketDataMsg, MarketDataMsg.Builder> {
  private MarketDataMsg() { }
  private static readonly MarketDataMsg defaultInstance = new MarketDataMsg().MakeReadOnly();
  private static readonly string[] _marketDataMsgFieldNames = new string[] { "AskPrice", "AskVolume", "AveragePrice", "AvgPriceInTick", "BidPrice", "BidVolume", "LastPrice", "LowerLimitPrice", "OpenInterest", "PreClosePrice", "PreOpenInterest", "PreSettlementPrice", "TradingDay", "Turnover", "UpdateMillisec", "UpdateTime", "UpperLimitPrice", "Volume", "accTurnover", "accVolume", "deltaOpenInsterest", "symbol" };
  private static readonly uint[] _marketDataMsgFieldTags = new uint[] { 113, 120, 177, 145, 129, 136, 41, 73, 49, 153, 169, 161, 18, 97, 32, 26, 65, 80, 105, 88, 56, 10 };
  public static MarketDataMsg DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override MarketDataMsg DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override MarketDataMsg ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::MarketData.internal__static_MarketDataMsg__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<MarketDataMsg, MarketDataMsg.Builder> InternalFieldAccessors {
    get { return global::MarketData.internal__static_MarketDataMsg__FieldAccessorTable; }
  }
  
  public const int SymbolFieldNumber = 1;
  private bool hasSymbol;
  private string symbol_ = "";
  public bool HasSymbol {
    get { return hasSymbol; }
  }
  public string Symbol {
    get { return symbol_; }
  }
  
  public const int TradingDayFieldNumber = 2;
  private bool hasTradingDay;
  private string tradingDay_ = "";
  public bool HasTradingDay {
    get { return hasTradingDay; }
  }
  public string TradingDay {
    get { return tradingDay_; }
  }
  
  public const int UpdateTimeFieldNumber = 3;
  private bool hasUpdateTime;
  private string updateTime_ = "";
  public bool HasUpdateTime {
    get { return hasUpdateTime; }
  }
  public string UpdateTime {
    get { return updateTime_; }
  }
  
  public const int UpdateMillisecFieldNumber = 4;
  private bool hasUpdateMillisec;
  private int updateMillisec_;
  public bool HasUpdateMillisec {
    get { return hasUpdateMillisec; }
  }
  public int UpdateMillisec {
    get { return updateMillisec_; }
  }
  
  public const int LastPriceFieldNumber = 5;
  private bool hasLastPrice;
  private double lastPrice_;
  public bool HasLastPrice {
    get { return hasLastPrice; }
  }
  public double LastPrice {
    get { return lastPrice_; }
  }
  
  public const int OpenInterestFieldNumber = 6;
  private bool hasOpenInterest;
  private double openInterest_;
  public bool HasOpenInterest {
    get { return hasOpenInterest; }
  }
  public double OpenInterest {
    get { return openInterest_; }
  }
  
  public const int DeltaOpenInsterestFieldNumber = 7;
  private bool hasDeltaOpenInsterest;
  private int deltaOpenInsterest_;
  public bool HasDeltaOpenInsterest {
    get { return hasDeltaOpenInsterest; }
  }
  public int DeltaOpenInsterest {
    get { return deltaOpenInsterest_; }
  }
  
  public const int UpperLimitPriceFieldNumber = 8;
  private bool hasUpperLimitPrice;
  private double upperLimitPrice_;
  public bool HasUpperLimitPrice {
    get { return hasUpperLimitPrice; }
  }
  public double UpperLimitPrice {
    get { return upperLimitPrice_; }
  }
  
  public const int LowerLimitPriceFieldNumber = 9;
  private bool hasLowerLimitPrice;
  private double lowerLimitPrice_;
  public bool HasLowerLimitPrice {
    get { return hasLowerLimitPrice; }
  }
  public double LowerLimitPrice {
    get { return lowerLimitPrice_; }
  }
  
  public const int VolumeFieldNumber = 10;
  private bool hasVolume;
  private int volume_;
  public bool HasVolume {
    get { return hasVolume; }
  }
  public int Volume {
    get { return volume_; }
  }
  
  public const int AccVolumeFieldNumber = 11;
  private bool hasAccVolume;
  private int accVolume_;
  public bool HasAccVolume {
    get { return hasAccVolume; }
  }
  public int AccVolume {
    get { return accVolume_; }
  }
  
  public const int TurnoverFieldNumber = 12;
  private bool hasTurnover;
  private double turnover_;
  public bool HasTurnover {
    get { return hasTurnover; }
  }
  public double Turnover {
    get { return turnover_; }
  }
  
  public const int AccTurnoverFieldNumber = 13;
  private bool hasAccTurnover;
  private double accTurnover_;
  public bool HasAccTurnover {
    get { return hasAccTurnover; }
  }
  public double AccTurnover {
    get { return accTurnover_; }
  }
  
  public const int AskPriceFieldNumber = 14;
  private bool hasAskPrice;
  private double askPrice_;
  public bool HasAskPrice {
    get { return hasAskPrice; }
  }
  public double AskPrice {
    get { return askPrice_; }
  }
  
  public const int AskVolumeFieldNumber = 15;
  private bool hasAskVolume;
  private int askVolume_;
  public bool HasAskVolume {
    get { return hasAskVolume; }
  }
  public int AskVolume {
    get { return askVolume_; }
  }
  
  public const int BidPriceFieldNumber = 16;
  private bool hasBidPrice;
  private double bidPrice_;
  public bool HasBidPrice {
    get { return hasBidPrice; }
  }
  public double BidPrice {
    get { return bidPrice_; }
  }
  
  public const int BidVolumeFieldNumber = 17;
  private bool hasBidVolume;
  private int bidVolume_;
  public bool HasBidVolume {
    get { return hasBidVolume; }
  }
  public int BidVolume {
    get { return bidVolume_; }
  }
  
  public const int AvgPriceInTickFieldNumber = 18;
  private bool hasAvgPriceInTick;
  private double avgPriceInTick_;
  public bool HasAvgPriceInTick {
    get { return hasAvgPriceInTick; }
  }
  public double AvgPriceInTick {
    get { return avgPriceInTick_; }
  }
  
  public const int PreClosePriceFieldNumber = 19;
  private bool hasPreClosePrice;
  private double preClosePrice_;
  public bool HasPreClosePrice {
    get { return hasPreClosePrice; }
  }
  public double PreClosePrice {
    get { return preClosePrice_; }
  }
  
  public const int PreSettlementPriceFieldNumber = 20;
  private bool hasPreSettlementPrice;
  private double preSettlementPrice_;
  public bool HasPreSettlementPrice {
    get { return hasPreSettlementPrice; }
  }
  public double PreSettlementPrice {
    get { return preSettlementPrice_; }
  }
  
  public const int PreOpenInterestFieldNumber = 21;
  private bool hasPreOpenInterest;
  private double preOpenInterest_;
  public bool HasPreOpenInterest {
    get { return hasPreOpenInterest; }
  }
  public double PreOpenInterest {
    get { return preOpenInterest_; }
  }
  
  public const int AveragePriceFieldNumber = 22;
  private bool hasAveragePrice;
  private double averagePrice_;
  public bool HasAveragePrice {
    get { return hasAveragePrice; }
  }
  public double AveragePrice {
    get { return averagePrice_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasSymbol) return false;
      if (!hasTradingDay) return false;
      if (!hasUpdateTime) return false;
      if (!hasUpdateMillisec) return false;
      if (!hasLastPrice) return false;
      if (!hasOpenInterest) return false;
      if (!hasDeltaOpenInsterest) return false;
      if (!hasUpperLimitPrice) return false;
      if (!hasLowerLimitPrice) return false;
      if (!hasVolume) return false;
      if (!hasAccVolume) return false;
      if (!hasTurnover) return false;
      if (!hasAccTurnover) return false;
      if (!hasAskPrice) return false;
      if (!hasAskVolume) return false;
      if (!hasBidPrice) return false;
      if (!hasBidVolume) return false;
      if (!hasAvgPriceInTick) return false;
      if (!hasPreClosePrice) return false;
      if (!hasPreSettlementPrice) return false;
      if (!hasPreOpenInterest) return false;
      if (!hasAveragePrice) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _marketDataMsgFieldNames;
    if (hasSymbol) {
      output.WriteString(1, field_names[21], Symbol);
    }
    if (hasTradingDay) {
      output.WriteString(2, field_names[12], TradingDay);
    }
    if (hasUpdateTime) {
      output.WriteString(3, field_names[15], UpdateTime);
    }
    if (hasUpdateMillisec) {
      output.WriteInt32(4, field_names[14], UpdateMillisec);
    }
    if (hasLastPrice) {
      output.WriteDouble(5, field_names[6], LastPrice);
    }
    if (hasOpenInterest) {
      output.WriteDouble(6, field_names[8], OpenInterest);
    }
    if (hasDeltaOpenInsterest) {
      output.WriteInt32(7, field_names[20], DeltaOpenInsterest);
    }
    if (hasUpperLimitPrice) {
      output.WriteDouble(8, field_names[16], UpperLimitPrice);
    }
    if (hasLowerLimitPrice) {
      output.WriteDouble(9, field_names[7], LowerLimitPrice);
    }
    if (hasVolume) {
      output.WriteInt32(10, field_names[17], Volume);
    }
    if (hasAccVolume) {
      output.WriteInt32(11, field_names[19], AccVolume);
    }
    if (hasTurnover) {
      output.WriteDouble(12, field_names[13], Turnover);
    }
    if (hasAccTurnover) {
      output.WriteDouble(13, field_names[18], AccTurnover);
    }
    if (hasAskPrice) {
      output.WriteDouble(14, field_names[0], AskPrice);
    }
    if (hasAskVolume) {
      output.WriteInt32(15, field_names[1], AskVolume);
    }
    if (hasBidPrice) {
      output.WriteDouble(16, field_names[4], BidPrice);
    }
    if (hasBidVolume) {
      output.WriteInt32(17, field_names[5], BidVolume);
    }
    if (hasAvgPriceInTick) {
      output.WriteDouble(18, field_names[3], AvgPriceInTick);
    }
    if (hasPreClosePrice) {
      output.WriteDouble(19, field_names[9], PreClosePrice);
    }
    if (hasPreSettlementPrice) {
      output.WriteDouble(20, field_names[11], PreSettlementPrice);
    }
    if (hasPreOpenInterest) {
      output.WriteDouble(21, field_names[10], PreOpenInterest);
    }
    if (hasAveragePrice) {
      output.WriteDouble(22, field_names[2], AveragePrice);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasSymbol) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Symbol);
    }
    if (hasTradingDay) {
      size += pb::CodedOutputStream.ComputeStringSize(2, TradingDay);
    }
    if (hasUpdateTime) {
      size += pb::CodedOutputStream.ComputeStringSize(3, UpdateTime);
    }
    if (hasUpdateMillisec) {
      size += pb::CodedOutputStream.ComputeInt32Size(4, UpdateMillisec);
    }
    if (hasLastPrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(5, LastPrice);
    }
    if (hasOpenInterest) {
      size += pb::CodedOutputStream.ComputeDoubleSize(6, OpenInterest);
    }
    if (hasDeltaOpenInsterest) {
      size += pb::CodedOutputStream.ComputeInt32Size(7, DeltaOpenInsterest);
    }
    if (hasUpperLimitPrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(8, UpperLimitPrice);
    }
    if (hasLowerLimitPrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(9, LowerLimitPrice);
    }
    if (hasVolume) {
      size += pb::CodedOutputStream.ComputeInt32Size(10, Volume);
    }
    if (hasAccVolume) {
      size += pb::CodedOutputStream.ComputeInt32Size(11, AccVolume);
    }
    if (hasTurnover) {
      size += pb::CodedOutputStream.ComputeDoubleSize(12, Turnover);
    }
    if (hasAccTurnover) {
      size += pb::CodedOutputStream.ComputeDoubleSize(13, AccTurnover);
    }
    if (hasAskPrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(14, AskPrice);
    }
    if (hasAskVolume) {
      size += pb::CodedOutputStream.ComputeInt32Size(15, AskVolume);
    }
    if (hasBidPrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(16, BidPrice);
    }
    if (hasBidVolume) {
      size += pb::CodedOutputStream.ComputeInt32Size(17, BidVolume);
    }
    if (hasAvgPriceInTick) {
      size += pb::CodedOutputStream.ComputeDoubleSize(18, AvgPriceInTick);
    }
    if (hasPreClosePrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(19, PreClosePrice);
    }
    if (hasPreSettlementPrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(20, PreSettlementPrice);
    }
    if (hasPreOpenInterest) {
      size += pb::CodedOutputStream.ComputeDoubleSize(21, PreOpenInterest);
    }
    if (hasAveragePrice) {
      size += pb::CodedOutputStream.ComputeDoubleSize(22, AveragePrice);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static MarketDataMsg ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static MarketDataMsg ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static MarketDataMsg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static MarketDataMsg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private MarketDataMsg MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(MarketDataMsg prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<MarketDataMsg, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(MarketDataMsg cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private MarketDataMsg result;
    
    private MarketDataMsg PrepareBuilder() {
      if (resultIsReadOnly) {
        MarketDataMsg original = result;
        result = new MarketDataMsg();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override MarketDataMsg MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::MarketDataMsg.Descriptor; }
    }
    
    public override MarketDataMsg DefaultInstanceForType {
      get { return global::MarketDataMsg.DefaultInstance; }
    }
    
    public override MarketDataMsg BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is MarketDataMsg) {
        return MergeFrom((MarketDataMsg) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(MarketDataMsg other) {
      if (other == global::MarketDataMsg.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSymbol) {
        Symbol = other.Symbol;
      }
      if (other.HasTradingDay) {
        TradingDay = other.TradingDay;
      }
      if (other.HasUpdateTime) {
        UpdateTime = other.UpdateTime;
      }
      if (other.HasUpdateMillisec) {
        UpdateMillisec = other.UpdateMillisec;
      }
      if (other.HasLastPrice) {
        LastPrice = other.LastPrice;
      }
      if (other.HasOpenInterest) {
        OpenInterest = other.OpenInterest;
      }
      if (other.HasDeltaOpenInsterest) {
        DeltaOpenInsterest = other.DeltaOpenInsterest;
      }
      if (other.HasUpperLimitPrice) {
        UpperLimitPrice = other.UpperLimitPrice;
      }
      if (other.HasLowerLimitPrice) {
        LowerLimitPrice = other.LowerLimitPrice;
      }
      if (other.HasVolume) {
        Volume = other.Volume;
      }
      if (other.HasAccVolume) {
        AccVolume = other.AccVolume;
      }
      if (other.HasTurnover) {
        Turnover = other.Turnover;
      }
      if (other.HasAccTurnover) {
        AccTurnover = other.AccTurnover;
      }
      if (other.HasAskPrice) {
        AskPrice = other.AskPrice;
      }
      if (other.HasAskVolume) {
        AskVolume = other.AskVolume;
      }
      if (other.HasBidPrice) {
        BidPrice = other.BidPrice;
      }
      if (other.HasBidVolume) {
        BidVolume = other.BidVolume;
      }
      if (other.HasAvgPriceInTick) {
        AvgPriceInTick = other.AvgPriceInTick;
      }
      if (other.HasPreClosePrice) {
        PreClosePrice = other.PreClosePrice;
      }
      if (other.HasPreSettlementPrice) {
        PreSettlementPrice = other.PreSettlementPrice;
      }
      if (other.HasPreOpenInterest) {
        PreOpenInterest = other.PreOpenInterest;
      }
      if (other.HasAveragePrice) {
        AveragePrice = other.AveragePrice;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_marketDataMsgFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _marketDataMsgFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasSymbol = input.ReadString(ref result.symbol_);
            break;
          }
          case 18: {
            result.hasTradingDay = input.ReadString(ref result.tradingDay_);
            break;
          }
          case 26: {
            result.hasUpdateTime = input.ReadString(ref result.updateTime_);
            break;
          }
          case 32: {
            result.hasUpdateMillisec = input.ReadInt32(ref result.updateMillisec_);
            break;
          }
          case 41: {
            result.hasLastPrice = input.ReadDouble(ref result.lastPrice_);
            break;
          }
          case 49: {
            result.hasOpenInterest = input.ReadDouble(ref result.openInterest_);
            break;
          }
          case 56: {
            result.hasDeltaOpenInsterest = input.ReadInt32(ref result.deltaOpenInsterest_);
            break;
          }
          case 65: {
            result.hasUpperLimitPrice = input.ReadDouble(ref result.upperLimitPrice_);
            break;
          }
          case 73: {
            result.hasLowerLimitPrice = input.ReadDouble(ref result.lowerLimitPrice_);
            break;
          }
          case 80: {
            result.hasVolume = input.ReadInt32(ref result.volume_);
            break;
          }
          case 88: {
            result.hasAccVolume = input.ReadInt32(ref result.accVolume_);
            break;
          }
          case 97: {
            result.hasTurnover = input.ReadDouble(ref result.turnover_);
            break;
          }
          case 105: {
            result.hasAccTurnover = input.ReadDouble(ref result.accTurnover_);
            break;
          }
          case 113: {
            result.hasAskPrice = input.ReadDouble(ref result.askPrice_);
            break;
          }
          case 120: {
            result.hasAskVolume = input.ReadInt32(ref result.askVolume_);
            break;
          }
          case 129: {
            result.hasBidPrice = input.ReadDouble(ref result.bidPrice_);
            break;
          }
          case 136: {
            result.hasBidVolume = input.ReadInt32(ref result.bidVolume_);
            break;
          }
          case 145: {
            result.hasAvgPriceInTick = input.ReadDouble(ref result.avgPriceInTick_);
            break;
          }
          case 153: {
            result.hasPreClosePrice = input.ReadDouble(ref result.preClosePrice_);
            break;
          }
          case 161: {
            result.hasPreSettlementPrice = input.ReadDouble(ref result.preSettlementPrice_);
            break;
          }
          case 169: {
            result.hasPreOpenInterest = input.ReadDouble(ref result.preOpenInterest_);
            break;
          }
          case 177: {
            result.hasAveragePrice = input.ReadDouble(ref result.averagePrice_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSymbol {
      get { return result.hasSymbol; }
    }
    public string Symbol {
      get { return result.Symbol; }
      set { SetSymbol(value); }
    }
    public Builder SetSymbol(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasSymbol = true;
      result.symbol_ = value;
      return this;
    }
    public Builder ClearSymbol() {
      PrepareBuilder();
      result.hasSymbol = false;
      result.symbol_ = "";
      return this;
    }
    
    public bool HasTradingDay {
      get { return result.hasTradingDay; }
    }
    public string TradingDay {
      get { return result.TradingDay; }
      set { SetTradingDay(value); }
    }
    public Builder SetTradingDay(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasTradingDay = true;
      result.tradingDay_ = value;
      return this;
    }
    public Builder ClearTradingDay() {
      PrepareBuilder();
      result.hasTradingDay = false;
      result.tradingDay_ = "";
      return this;
    }
    
    public bool HasUpdateTime {
      get { return result.hasUpdateTime; }
    }
    public string UpdateTime {
      get { return result.UpdateTime; }
      set { SetUpdateTime(value); }
    }
    public Builder SetUpdateTime(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasUpdateTime = true;
      result.updateTime_ = value;
      return this;
    }
    public Builder ClearUpdateTime() {
      PrepareBuilder();
      result.hasUpdateTime = false;
      result.updateTime_ = "";
      return this;
    }
    
    public bool HasUpdateMillisec {
      get { return result.hasUpdateMillisec; }
    }
    public int UpdateMillisec {
      get { return result.UpdateMillisec; }
      set { SetUpdateMillisec(value); }
    }
    public Builder SetUpdateMillisec(int value) {
      PrepareBuilder();
      result.hasUpdateMillisec = true;
      result.updateMillisec_ = value;
      return this;
    }
    public Builder ClearUpdateMillisec() {
      PrepareBuilder();
      result.hasUpdateMillisec = false;
      result.updateMillisec_ = 0;
      return this;
    }
    
    public bool HasLastPrice {
      get { return result.hasLastPrice; }
    }
    public double LastPrice {
      get { return result.LastPrice; }
      set { SetLastPrice(value); }
    }
    public Builder SetLastPrice(double value) {
      PrepareBuilder();
      result.hasLastPrice = true;
      result.lastPrice_ = value;
      return this;
    }
    public Builder ClearLastPrice() {
      PrepareBuilder();
      result.hasLastPrice = false;
      result.lastPrice_ = 0D;
      return this;
    }
    
    public bool HasOpenInterest {
      get { return result.hasOpenInterest; }
    }
    public double OpenInterest {
      get { return result.OpenInterest; }
      set { SetOpenInterest(value); }
    }
    public Builder SetOpenInterest(double value) {
      PrepareBuilder();
      result.hasOpenInterest = true;
      result.openInterest_ = value;
      return this;
    }
    public Builder ClearOpenInterest() {
      PrepareBuilder();
      result.hasOpenInterest = false;
      result.openInterest_ = 0D;
      return this;
    }
    
    public bool HasDeltaOpenInsterest {
      get { return result.hasDeltaOpenInsterest; }
    }
    public int DeltaOpenInsterest {
      get { return result.DeltaOpenInsterest; }
      set { SetDeltaOpenInsterest(value); }
    }
    public Builder SetDeltaOpenInsterest(int value) {
      PrepareBuilder();
      result.hasDeltaOpenInsterest = true;
      result.deltaOpenInsterest_ = value;
      return this;
    }
    public Builder ClearDeltaOpenInsterest() {
      PrepareBuilder();
      result.hasDeltaOpenInsterest = false;
      result.deltaOpenInsterest_ = 0;
      return this;
    }
    
    public bool HasUpperLimitPrice {
      get { return result.hasUpperLimitPrice; }
    }
    public double UpperLimitPrice {
      get { return result.UpperLimitPrice; }
      set { SetUpperLimitPrice(value); }
    }
    public Builder SetUpperLimitPrice(double value) {
      PrepareBuilder();
      result.hasUpperLimitPrice = true;
      result.upperLimitPrice_ = value;
      return this;
    }
    public Builder ClearUpperLimitPrice() {
      PrepareBuilder();
      result.hasUpperLimitPrice = false;
      result.upperLimitPrice_ = 0D;
      return this;
    }
    
    public bool HasLowerLimitPrice {
      get { return result.hasLowerLimitPrice; }
    }
    public double LowerLimitPrice {
      get { return result.LowerLimitPrice; }
      set { SetLowerLimitPrice(value); }
    }
    public Builder SetLowerLimitPrice(double value) {
      PrepareBuilder();
      result.hasLowerLimitPrice = true;
      result.lowerLimitPrice_ = value;
      return this;
    }
    public Builder ClearLowerLimitPrice() {
      PrepareBuilder();
      result.hasLowerLimitPrice = false;
      result.lowerLimitPrice_ = 0D;
      return this;
    }
    
    public bool HasVolume {
      get { return result.hasVolume; }
    }
    public int Volume {
      get { return result.Volume; }
      set { SetVolume(value); }
    }
    public Builder SetVolume(int value) {
      PrepareBuilder();
      result.hasVolume = true;
      result.volume_ = value;
      return this;
    }
    public Builder ClearVolume() {
      PrepareBuilder();
      result.hasVolume = false;
      result.volume_ = 0;
      return this;
    }
    
    public bool HasAccVolume {
      get { return result.hasAccVolume; }
    }
    public int AccVolume {
      get { return result.AccVolume; }
      set { SetAccVolume(value); }
    }
    public Builder SetAccVolume(int value) {
      PrepareBuilder();
      result.hasAccVolume = true;
      result.accVolume_ = value;
      return this;
    }
    public Builder ClearAccVolume() {
      PrepareBuilder();
      result.hasAccVolume = false;
      result.accVolume_ = 0;
      return this;
    }
    
    public bool HasTurnover {
      get { return result.hasTurnover; }
    }
    public double Turnover {
      get { return result.Turnover; }
      set { SetTurnover(value); }
    }
    public Builder SetTurnover(double value) {
      PrepareBuilder();
      result.hasTurnover = true;
      result.turnover_ = value;
      return this;
    }
    public Builder ClearTurnover() {
      PrepareBuilder();
      result.hasTurnover = false;
      result.turnover_ = 0D;
      return this;
    }
    
    public bool HasAccTurnover {
      get { return result.hasAccTurnover; }
    }
    public double AccTurnover {
      get { return result.AccTurnover; }
      set { SetAccTurnover(value); }
    }
    public Builder SetAccTurnover(double value) {
      PrepareBuilder();
      result.hasAccTurnover = true;
      result.accTurnover_ = value;
      return this;
    }
    public Builder ClearAccTurnover() {
      PrepareBuilder();
      result.hasAccTurnover = false;
      result.accTurnover_ = 0D;
      return this;
    }
    
    public bool HasAskPrice {
      get { return result.hasAskPrice; }
    }
    public double AskPrice {
      get { return result.AskPrice; }
      set { SetAskPrice(value); }
    }
    public Builder SetAskPrice(double value) {
      PrepareBuilder();
      result.hasAskPrice = true;
      result.askPrice_ = value;
      return this;
    }
    public Builder ClearAskPrice() {
      PrepareBuilder();
      result.hasAskPrice = false;
      result.askPrice_ = 0D;
      return this;
    }
    
    public bool HasAskVolume {
      get { return result.hasAskVolume; }
    }
    public int AskVolume {
      get { return result.AskVolume; }
      set { SetAskVolume(value); }
    }
    public Builder SetAskVolume(int value) {
      PrepareBuilder();
      result.hasAskVolume = true;
      result.askVolume_ = value;
      return this;
    }
    public Builder ClearAskVolume() {
      PrepareBuilder();
      result.hasAskVolume = false;
      result.askVolume_ = 0;
      return this;
    }
    
    public bool HasBidPrice {
      get { return result.hasBidPrice; }
    }
    public double BidPrice {
      get { return result.BidPrice; }
      set { SetBidPrice(value); }
    }
    public Builder SetBidPrice(double value) {
      PrepareBuilder();
      result.hasBidPrice = true;
      result.bidPrice_ = value;
      return this;
    }
    public Builder ClearBidPrice() {
      PrepareBuilder();
      result.hasBidPrice = false;
      result.bidPrice_ = 0D;
      return this;
    }
    
    public bool HasBidVolume {
      get { return result.hasBidVolume; }
    }
    public int BidVolume {
      get { return result.BidVolume; }
      set { SetBidVolume(value); }
    }
    public Builder SetBidVolume(int value) {
      PrepareBuilder();
      result.hasBidVolume = true;
      result.bidVolume_ = value;
      return this;
    }
    public Builder ClearBidVolume() {
      PrepareBuilder();
      result.hasBidVolume = false;
      result.bidVolume_ = 0;
      return this;
    }
    
    public bool HasAvgPriceInTick {
      get { return result.hasAvgPriceInTick; }
    }
    public double AvgPriceInTick {
      get { return result.AvgPriceInTick; }
      set { SetAvgPriceInTick(value); }
    }
    public Builder SetAvgPriceInTick(double value) {
      PrepareBuilder();
      result.hasAvgPriceInTick = true;
      result.avgPriceInTick_ = value;
      return this;
    }
    public Builder ClearAvgPriceInTick() {
      PrepareBuilder();
      result.hasAvgPriceInTick = false;
      result.avgPriceInTick_ = 0D;
      return this;
    }
    
    public bool HasPreClosePrice {
      get { return result.hasPreClosePrice; }
    }
    public double PreClosePrice {
      get { return result.PreClosePrice; }
      set { SetPreClosePrice(value); }
    }
    public Builder SetPreClosePrice(double value) {
      PrepareBuilder();
      result.hasPreClosePrice = true;
      result.preClosePrice_ = value;
      return this;
    }
    public Builder ClearPreClosePrice() {
      PrepareBuilder();
      result.hasPreClosePrice = false;
      result.preClosePrice_ = 0D;
      return this;
    }
    
    public bool HasPreSettlementPrice {
      get { return result.hasPreSettlementPrice; }
    }
    public double PreSettlementPrice {
      get { return result.PreSettlementPrice; }
      set { SetPreSettlementPrice(value); }
    }
    public Builder SetPreSettlementPrice(double value) {
      PrepareBuilder();
      result.hasPreSettlementPrice = true;
      result.preSettlementPrice_ = value;
      return this;
    }
    public Builder ClearPreSettlementPrice() {
      PrepareBuilder();
      result.hasPreSettlementPrice = false;
      result.preSettlementPrice_ = 0D;
      return this;
    }
    
    public bool HasPreOpenInterest {
      get { return result.hasPreOpenInterest; }
    }
    public double PreOpenInterest {
      get { return result.PreOpenInterest; }
      set { SetPreOpenInterest(value); }
    }
    public Builder SetPreOpenInterest(double value) {
      PrepareBuilder();
      result.hasPreOpenInterest = true;
      result.preOpenInterest_ = value;
      return this;
    }
    public Builder ClearPreOpenInterest() {
      PrepareBuilder();
      result.hasPreOpenInterest = false;
      result.preOpenInterest_ = 0D;
      return this;
    }
    
    public bool HasAveragePrice {
      get { return result.hasAveragePrice; }
    }
    public double AveragePrice {
      get { return result.AveragePrice; }
      set { SetAveragePrice(value); }
    }
    public Builder SetAveragePrice(double value) {
      PrepareBuilder();
      result.hasAveragePrice = true;
      result.averagePrice_ = value;
      return this;
    }
    public Builder ClearAveragePrice() {
      PrepareBuilder();
      result.hasAveragePrice = false;
      result.averagePrice_ = 0D;
      return this;
    }
  }
  static MarketDataMsg() {
    object.ReferenceEquals(global::MarketData.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class InstrumentInfo : pb::GeneratedMessage<InstrumentInfo, InstrumentInfo.Builder> {
  private InstrumentInfo() { }
  private static readonly InstrumentInfo defaultInstance = new InstrumentInfo().MakeReadOnly();
  private static readonly string[] _instrumentInfoFieldNames = new string[] { "PriceTick", "Symbol" };
  private static readonly uint[] _instrumentInfoFieldTags = new uint[] { 17, 10 };
  public static InstrumentInfo DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override InstrumentInfo DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override InstrumentInfo ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::MarketData.internal__static_InstrumentInfo__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<InstrumentInfo, InstrumentInfo.Builder> InternalFieldAccessors {
    get { return global::MarketData.internal__static_InstrumentInfo__FieldAccessorTable; }
  }
  
  public const int SymbolFieldNumber = 1;
  private bool hasSymbol;
  private string symbol_ = "";
  public bool HasSymbol {
    get { return hasSymbol; }
  }
  public string Symbol {
    get { return symbol_; }
  }
  
  public const int PriceTickFieldNumber = 2;
  private bool hasPriceTick;
  private double priceTick_ = 1D;
  public bool HasPriceTick {
    get { return hasPriceTick; }
  }
  public double PriceTick {
    get { return priceTick_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasSymbol) return false;
      if (!hasPriceTick) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _instrumentInfoFieldNames;
    if (hasSymbol) {
      output.WriteString(1, field_names[1], Symbol);
    }
    if (hasPriceTick) {
      output.WriteDouble(2, field_names[0], PriceTick);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasSymbol) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Symbol);
    }
    if (hasPriceTick) {
      size += pb::CodedOutputStream.ComputeDoubleSize(2, PriceTick);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static InstrumentInfo ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static InstrumentInfo ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static InstrumentInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static InstrumentInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private InstrumentInfo MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(InstrumentInfo prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<InstrumentInfo, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(InstrumentInfo cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private InstrumentInfo result;
    
    private InstrumentInfo PrepareBuilder() {
      if (resultIsReadOnly) {
        InstrumentInfo original = result;
        result = new InstrumentInfo();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override InstrumentInfo MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::InstrumentInfo.Descriptor; }
    }
    
    public override InstrumentInfo DefaultInstanceForType {
      get { return global::InstrumentInfo.DefaultInstance; }
    }
    
    public override InstrumentInfo BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is InstrumentInfo) {
        return MergeFrom((InstrumentInfo) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(InstrumentInfo other) {
      if (other == global::InstrumentInfo.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSymbol) {
        Symbol = other.Symbol;
      }
      if (other.HasPriceTick) {
        PriceTick = other.PriceTick;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_instrumentInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _instrumentInfoFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasSymbol = input.ReadString(ref result.symbol_);
            break;
          }
          case 17: {
            result.hasPriceTick = input.ReadDouble(ref result.priceTick_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSymbol {
      get { return result.hasSymbol; }
    }
    public string Symbol {
      get { return result.Symbol; }
      set { SetSymbol(value); }
    }
    public Builder SetSymbol(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasSymbol = true;
      result.symbol_ = value;
      return this;
    }
    public Builder ClearSymbol() {
      PrepareBuilder();
      result.hasSymbol = false;
      result.symbol_ = "";
      return this;
    }
    
    public bool HasPriceTick {
      get { return result.hasPriceTick; }
    }
    public double PriceTick {
      get { return result.PriceTick; }
      set { SetPriceTick(value); }
    }
    public Builder SetPriceTick(double value) {
      PrepareBuilder();
      result.hasPriceTick = true;
      result.priceTick_ = value;
      return this;
    }
    public Builder ClearPriceTick() {
      PrepareBuilder();
      result.hasPriceTick = false;
      result.priceTick_ = 1D;
      return this;
    }
  }
  static InstrumentInfo() {
    object.ReferenceEquals(global::MarketData.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class InstrumentList : pb::GeneratedMessage<InstrumentList, InstrumentList.Builder> {
  private InstrumentList() { }
  private static readonly InstrumentList defaultInstance = new InstrumentList().MakeReadOnly();
  private static readonly string[] _instrumentListFieldNames = new string[] { "lst" };
  private static readonly uint[] _instrumentListFieldTags = new uint[] { 10 };
  public static InstrumentList DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override InstrumentList DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override InstrumentList ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::MarketData.internal__static_InstrumentList__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<InstrumentList, InstrumentList.Builder> InternalFieldAccessors {
    get { return global::MarketData.internal__static_InstrumentList__FieldAccessorTable; }
  }
  
  public const int LstFieldNumber = 1;
  private pbc::PopsicleList<global::InstrumentInfo> lst_ = new pbc::PopsicleList<global::InstrumentInfo>();
  public scg::IList<global::InstrumentInfo> LstList {
    get { return lst_; }
  }
  public int LstCount {
    get { return lst_.Count; }
  }
  public global::InstrumentInfo GetLst(int index) {
    return lst_[index];
  }
  
  public override bool IsInitialized {
    get {
      foreach (global::InstrumentInfo element in LstList) {
        if (!element.IsInitialized) return false;
      }
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _instrumentListFieldNames;
    if (lst_.Count > 0) {
      output.WriteMessageArray(1, field_names[0], lst_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    foreach (global::InstrumentInfo element in LstList) {
      size += pb::CodedOutputStream.ComputeMessageSize(1, element);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static InstrumentList ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static InstrumentList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static InstrumentList ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static InstrumentList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static InstrumentList ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static InstrumentList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static InstrumentList ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static InstrumentList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static InstrumentList ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static InstrumentList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private InstrumentList MakeReadOnly() {
    lst_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(InstrumentList prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<InstrumentList, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(InstrumentList cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private InstrumentList result;
    
    private InstrumentList PrepareBuilder() {
      if (resultIsReadOnly) {
        InstrumentList original = result;
        result = new InstrumentList();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override InstrumentList MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::InstrumentList.Descriptor; }
    }
    
    public override InstrumentList DefaultInstanceForType {
      get { return global::InstrumentList.DefaultInstance; }
    }
    
    public override InstrumentList BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is InstrumentList) {
        return MergeFrom((InstrumentList) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(InstrumentList other) {
      if (other == global::InstrumentList.DefaultInstance) return this;
      PrepareBuilder();
      if (other.lst_.Count != 0) {
        result.lst_.Add(other.lst_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_instrumentListFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _instrumentListFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            input.ReadMessageArray(tag, field_name, result.lst_, global::InstrumentInfo.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public pbc::IPopsicleList<global::InstrumentInfo> LstList {
      get { return PrepareBuilder().lst_; }
    }
    public int LstCount {
      get { return result.LstCount; }
    }
    public global::InstrumentInfo GetLst(int index) {
      return result.GetLst(index);
    }
    public Builder SetLst(int index, global::InstrumentInfo value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.lst_[index] = value;
      return this;
    }
    public Builder SetLst(int index, global::InstrumentInfo.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.lst_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddLst(global::InstrumentInfo value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.lst_.Add(value);
      return this;
    }
    public Builder AddLst(global::InstrumentInfo.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.lst_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeLst(scg::IEnumerable<global::InstrumentInfo> values) {
      PrepareBuilder();
      result.lst_.Add(values);
      return this;
    }
    public Builder ClearLst() {
      PrepareBuilder();
      result.lst_.Clear();
      return this;
    }
  }
  static InstrumentList() {
    object.ReferenceEquals(global::MarketData.Descriptor, null);
  }
}

#endregion


#endregion Designer generated code
